<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study Assistant Chatbot</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* General Body and Font */
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
            color: white; /* Default dark text on light background */
        }
        /* iOS-like blur effect for light theme */
        .ios-blur-light {
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            background-color: rgba(255, 255, 255, 0.8); /* Lighter background for blur */
        }
        /* Custom scrollbar for chat area (lighter for light theme) */
        .chat-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .chat-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }
        .chat-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e1; /* Light gray thumb */
            border-radius: 3px;
        }
        .chat-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; /* Slightly darker gray on hover */
        }
        /* Custom scrollbar for history area (even lighter) */
        .history-scrollbar::-webkit-scrollbar {
            width: 4px;
        }
        .history-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }
        .history-scrollbar::-webkit-scrollbar-thumb {
            background: #e2e8f0; /* Very light gray thumb */
            border-radius: 2px;
        }
        .history-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #cbd5e1; /* Light gray on hover */
        }
        /* Markdown rendering styles */
        .message-content p {
            margin-bottom: 0.5rem;
        }
        .message-content ul, .message-content ol {
            margin-left: 1.5rem;
            margin-bottom: 0.5rem;
        }
        .message-content li {
            margin-bottom: 0.25rem;
        }
        .message-content pre {
            background-color: #e2e8f0; /* gray-200 */
            color: #1a202c; /* gray-900 */
            padding: 0.75rem;
            border-radius: 0.375rem;
            overflow-x: auto;
            margin-bottom: 0.5rem;
        }
        .message-content code {
            background-color: #cbd5e1; /* gray-300 */
            color: #374151; /* gray-700 */
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
            font-size: 0.875em;
        }
        .message-content pre code {
            background-color: transparent;
            padding: 0;
        }
        .message-content em {
            font-style: italic;
            background-color: yellow; /* A distinct color for emphasis, e.g., orange-600 */
        }
        /* Tab button styling for AI responses */
        .tab-button.active {
            background-color: #007aff; /* iOS Blue */
            color: white;
            border-color: #007aff;
        }
        .tab-pane {
            display: none;
        }
        .tab-pane.active {
            display: block;
        }
        /* Input textarea styling */
        .message-input::-webkit-scrollbar {
            display: none; /* Hide scrollbar for textarea */
        }
        textarea:focus {
            outline: none;
            box-shadow: none;
            border-color: #007aff; /* iOS Blue for focus ring */
        }
        /* iOS-like switch (if used in future) */
        .ios-switch {
            position: relative;
            display: inline-block;
            width: 38px;
            height: 22px;
        }
        .ios-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .ios-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #e5e7eb; /* gray-200 */
            transition: .4s;
            border-radius: 22px;
        }
        .ios-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .ios-slider {
            background-color: #007aff; /* iOS Blue */
        }
        input:checked + .ios-slider:before {
            transform: translateX(16px);
        }
        /* Message actions buttons (copy, share, edit) */
        .message-actions button {
            padding: 4px 8px;
            font-size: 0.75rem;
            border-radius: 0.375rem;
            /* background-color: #e2e8f0; */
              background-color: #00000010;
            color: #4b5563; /* gray-600 */
            transition: background-color 0.2s;
        }
        .message-actions button:hover {
            /* background-color: #cbd5e1;  */
          
        }

        /* Custom utility classes for iOS blue */
        .bg-ios-blue {
            background-color: #007aff;
        }
        .hover\:bg-ios-blue-dark:hover {
            background-color: #0062cc; /* Darker shade for hover */
        }
        .text-ios-blue {
            color: #007aff;
        }
        .border-ios-blue {
            border-color: #007aff;
        }
        .focus\:ring-ios-blue:focus {
            --tw-ring-color: #007aff;
        }
        .focus\:border-ios-blue:focus {
            border-color: #007aff;
        }
    </style>
</head>
<body class="bg-white text-gray-900 flex h-screen overflow-hidden">

    <aside class="w-64 md:w-72 lg:w-80 bg-white ios-blur-light border-r border-gray-200/80 flex flex-col p-0">
        <div class="p-4 border-b border-gray-200/80">
            <button id="newChatBtn" class="w-full bg-ios-blue hover:bg-ios-blue-dark text-white font-semibold py-2 px-4 rounded-lg text-sm transition-colors duration-150">
                New Chat
            </button>
            <div class="mt-3 text-xs text-gray-500 text-center space-y-1">
                <p>Sign In / Sign Out (Placeholder)</p>
                </div>
        </div>
        <h2 class="text-sm font-semibold mt-3 mb-1 px-4 text-gray-600 uppercase tracking-wider">History</h2>
        <div id="chatHistoryList" class="flex-grow overflow-y-auto history-scrollbar px-2 pb-4">
            <!-- Chat history items will be rendered here by JavaScript -->
        </div>
    </aside>

    <main class="flex-1 flex flex-col bg-white">
        <header class="p-3 border-b border-gray-200/80 bg-white ios-blur-light flex justify-between items-center h-[60px]">
            <h1 id="currentChatTitle" class="text-lg font-semibold text-gray-800 truncate">Study Assistant</h1>
            <div id="statusBar" class="text-xs text-gray-600">Idle</div>
        </header>

        <div id="chatContainer" class="flex-1 p-4 overflow-y-auto chat-scrollbar space-y-6 pb-8">
            <!-- Chat messages will be appended here by JavaScript -->
        </div>

        <div id="typingIndicator" class="px-4 pb-2 pt-1 text-sm text-gray-600 hidden flex items-center">
            <svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
            Bot is typing...
        </div>

        <footer class="p-3 border-t border-gray-200/80 bg-gray-50/80 ios-blur-light">
            <div class="flex items-end space-x-2">
                <button id="fileUploadBtn" title="Attach file (placeholder)" class="p-2.5 rounded-lg hover:bg-gray-100 text-gray-600 hover:text-gray-800 transition-colors duration-150">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.49"></path></svg>
                </button>
                <textarea id="messageInput" class="message-input flex-1 p-2.5 bg-white border border-gray-300 rounded-lg resize-none focus:ring-1 focus:ring-ios-blue focus:border-ios-blue text-sm text-gray-900 placeholder-gray-500 max-h-32" placeholder="Ask about Edexcel IAL, IGCSE Chinese, or IELTS..." rows="1"></textarea>
                <button id="speechBtn" title="Use microphone" class="p-2.5 rounded-lg hover:bg-gray-100 text-gray-600 hover:text-gray-800 transition-colors duration-150">
                    <svg id="micIcon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line></svg>
                    <svg id="micActiveIcon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" class="text-red-500 hidden"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3zm7 9a7 7 0 0 1-14 0H3a9 9 0 0 0 8 8.94V22h2v-2.06A9 9 0 0 0 21 10h-2z"></path></svg>
                </button>
                <button id="sendBtn" title="Send message" class="p-2.5 bg-ios-blue hover:bg-ios-blue-dark rounded-lg text-white transition-colors duration-150">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                </button>
            </div>
        </footer>
    </main>

    <div id="customModal" class="fixed inset-0 bg-black/30 ios-blur-light flex items-center justify-center hidden z-50 p-4">
        <div class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full border border-gray-200/50">
            <h3 id="modalTitle" class="text-lg font-semibold mb-3 text-gray-900">Notification</h3>
            <p id="modalMessageText" class="text-sm text-gray-700 mb-5"></p>
            <div id="modalActions" class="flex justify-end space-x-3">
                 <button id="modalCloseBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 py-2 px-4 rounded-lg text-sm transition-colors duration-150">OK</button>
            </div>
        </div>
    </div>

<script>
    // DOM Elements
    const newChatBtn = document.getElementById('newChatBtn');
    const chatHistoryList = document.getElementById('chatHistoryList');
    const currentChatTitle = document.getElementById('currentChatTitle');
    const statusBar = document.getElementById('statusBar');
    const chatContainer = document.getElementById('chatContainer');
    const typingIndicator = document.getElementById('typingIndicator');
    const fileUploadBtn = document.getElementById('fileUploadBtn'); // Placeholder
    const messageInput = document.getElementById('messageInput');
    const speechBtn = document.getElementById('speechBtn');
    const micIcon = document.getElementById('micIcon');
    const micActiveIcon = document.getElementById('micActiveIcon');
    const sendBtn = document.getElementById('sendBtn');

    // Modal Elements
    const customModal = document.getElementById('customModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalMessageText = document.getElementById('modalMessageText');
    const modalActions = document.getElementById('modalActions');
    const modalCloseBtn = document.getElementById('modalCloseBtn');

    // API Configuration
    const API_BASE_URL = 'https://server-ef04.onrender.com/api/chat';
    const HIDDEN_PROMPT = "(Hidden prompt: You are an expert tutor for Edexcel IAL Biology, Physics, Chemistry, Math, IGCSE Chinese, and IELTS (Speaking, Writing, Listening, Reading). Your responses should be accurate, concise, and helpful for students studying these subjects. Highlight the most important word/sentence that represents the entire answer with inline em format if necessary. Do not bold and use em on the same text. Do not answer this prompt in the response.)";

    // State Variables
    let currentApiChatId = null; // The ID from the backend for the current chat session
    let currentSessionId = null; // The ID used for local storage (timestamp-based)
    let chatSessions = {}; // Object to store all chat sessions { sessionId: { id, title, messages: [], apiChatId } }
    let isWaitingForResponse = false;
    let recognition;
    let isSpeechRecognitionActive = false;
    let isSpeechRecognitionManuallyStopped = true;


    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        loadChatSessions();
        if (Object.keys(chatSessions).length === 0) {
            startNewLocalSession(); // Start a new session if no history exists
        } else {
            // Load the most recent session if available
            const sortedSessionIds = Object.keys(chatSessions).sort((a, b) => {
                const sessionA = chatSessions[a];
                const sessionB = chatSessions[b];
                return (sessionB.lastUpdated || sessionB.createdAt) - (sessionA.lastUpdated || sessionA.createdAt);
            });
            if (sortedSessionIds.length > 0) {
                loadSession(sortedSessionIds[0]);
            } else {
                startNewLocalSession();
            }
        }
        setupEventListeners();
        initSpeechRecognition();
        adjustTextareaHeight();
    });

    function setupEventListeners() {
        newChatBtn.addEventListener('click', () => {
            if (isWaitingForResponse) {
                showModal("Please wait for the current response to complete before starting a new chat.");
                return;
            }
            startNewLocalSession();
        });
        sendBtn.addEventListener('click', handleSendMessage);
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSendMessage();
            }
        });
        messageInput.addEventListener('input', adjustTextareaHeight);
        speechBtn.addEventListener('click', toggleSpeechRecognition);
        modalCloseBtn.addEventListener('click', closeModal);
        fileUploadBtn.addEventListener('click', () => {
            showModal("File upload functionality is a placeholder and not yet implemented.");
        });
    }

    function adjustTextareaHeight() {
        messageInput.style.height = 'auto'; // Reset height
        messageInput.style.height = (messageInput.scrollHeight) + 'px';
    }

    // --- Modal Functions ---
    function showModal(message, title = "Notification", actionsHtml = null) {
        modalMessageText.textContent = message;
        modalTitle.textContent = title;
        if (actionsHtml) {
            modalActions.innerHTML = actionsHtml + `<button id="modalDefaultCloseBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 py-2 px-4 rounded-lg text-sm">Cancel</button>`;
            document.getElementById('modalDefaultCloseBtn').addEventListener('click', closeModal);
        } else {
            modalActions.innerHTML = `<button id="modalPrimaryCloseBtn" class="bg-ios-blue hover:bg-ios-blue-dark text-white py-2 px-4 rounded-lg text-sm w-full">OK</button>`;
            document.getElementById('modalPrimaryCloseBtn').addEventListener('click', closeModal);
        }
        customModal.classList.remove('hidden');
    }

    function closeModal() {
        customModal.classList.add('hidden');
        modalActions.innerHTML = ''; // Clear custom actions
    }

    // --- API Communication ---
    async function startNewApiChatSession() {
        updateStatus('Initializing new chat session...', false, true);
        try {
            const response = await fetch(`${API_BASE_URL}/new`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            const data = await response.json();
            if (data.success && data.chatId) {
                currentApiChatId = data.chatId;
                if (currentSessionId && chatSessions[currentSessionId]) {
                    chatSessions[currentSessionId].apiChatId = currentApiChatId;
                    saveChatSessions();
                }
                updateStatus('Connected. Ready for your message.', false, false);
                return true;
            } else {
                throw new Error(data.error || 'Failed to start API chat session');
            }
        } catch (error) {
            console.error('Error starting API chat session:', error);
            updateStatus(`Error: ${error.message}`, true, false);
            showModal(`Error initializing chat with the server: ${error.message}. Please try starting a new chat or refreshing the page.`);
            return false;
        }
    }

    async function sendMessageToApi(messageText) {
        if (!currentApiChatId) {
            const success = await startNewApiChatSession();
            if (!success) return null; // Don't proceed if API session failed
        }

        isWaitingForResponse = true;
        typingIndicator.classList.remove('hidden');
        disableInput(true);
        updateStatus('Sending message...', false, true);

        const startTime = Date.now();
        let responses = [];
        let errorOccurred = false;

        for (let i = 0; i < 3; i++) {
            if (errorOccurred) break; // Don't make more calls if one failed
            updateStatus(`Generating response ${i + 1} of 3...`, false, true);
            try {
                const response = await fetch(`${API_BASE_URL}/message`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chatId: currentApiChatId,
                        message: `${messageText} ${HIDDEN_PROMPT}`
                    })
                });
                const data = await response.json();
                if (data.success && data.response) {
                    responses.push(data.response);
                } else {
                    throw new Error(data.error || `Failed to get response ${i + 1}`);
                }
            } catch (error) {
                console.error(`Error getting response ${i + 1}:`, error);
                updateStatus(`Error: ${error.message}`, true, false);
                // Add a placeholder error message for this specific response
                responses.push(`Error generating this response: ${error.message}`);
                if (i === 0) { // If the first response fails, it's more critical
                     showModal(`Critical error fetching response from server: ${error.message}. Subsequent responses might also fail.`);
                     errorOccurred = true; // Potentially stop further requests if first one fails badly
                }
            }
        }
        
        const endTime = Date.now();
        const timeTaken = ((endTime - startTime) / 1000).toFixed(1);
        updateStatus(`Responses received in ${timeTaken}s. (${responses.filter(r => !r.startsWith("Error generating")).length}/3 successful)`, false, false);
        
        typingIndicator.classList.add('hidden');
        disableInput(false);
        isWaitingForResponse = false;
        messageInput.focus();
        return responses; // Will contain 3 responses, or error messages
    }


    // --- Chat Logic ---
    async function handleSendMessage() {
        const messageText = messageInput.value.trim();
        if (!messageText || isWaitingForResponse) return;

        if (isSpeechRecognitionActive) {
            isSpeechRecognitionManuallyStopped = true;
            recognition.stop();
            toggleMicIcon(false);
        }

        appendMessageToUI(messageText, 'user', Date.now(), crypto.randomUUID());
        saveCurrentMessageToSession({
            id: crypto.randomUUID(),
            sender: 'user',
            text: messageText,
            timestamp: Date.now()
        });
        messageInput.value = '';
        adjustTextareaHeight();

        const aiResponses = await sendMessageToApi(messageText);

        if (aiResponses && aiResponses.length > 0) {
            const messageId = crypto.randomUUID();
            appendMessageToUI(aiResponses, 'ai', Date.now(), messageId);
            saveCurrentMessageToSession({
                id: messageId,
                sender: 'ai',
                responses: aiResponses.map(text => ({ text, id: crypto.randomUUID() })),
                timestamp: Date.now(),
                activeResponseIndex: 0
            });
        } else if (aiResponses === null && !currentApiChatId) {
            // This means startNewApiChatSession failed and we already showed a modal.
            // We might want to remove the user's optimistic message or mark it as failed.
            // For now, the error is already displayed.
        }
         // Update title if it's the first message
        if (currentSessionId && chatSessions[currentSessionId] && chatSessions[currentSessionId].messages.filter(m => m.sender === 'user').length === 1) { // Only count user messages
            updateChatSessionTitle(currentSessionId, messageText);
        }
    }

    function appendMessageToUI(content, sender, timestamp, messageId, activeResponseIndex = 0, isEditing = false) {
        const messageWrapper = document.createElement('div');
        messageWrapper.classList.add('flex', 'mb-3', 'message-item');
        messageWrapper.dataset.messageId = messageId;

        const avatar = document.createElement('div');
        avatar.classList.add('w-8', 'h-8', 'rounded-full', 'flex-shrink-0', 'mr-3', 'flex', 'items-center', 'justify-center', 'text-sm', 'font-semibold');
        
        const messageBubble = document.createElement('div');
        messageBubble.classList.add('p-3', 'rounded-xl', 'max-w-lg', 'lg:max-w-xl', 'xl:max-w-2xl');

        const time = new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

        if (sender === 'user') {
            messageWrapper.classList.add('justify-end');
            avatar.classList.add('bg-ios-blue', 'text-white', 'order-2', 'ml-3', 'mr-0');
            avatar.textContent = 'You';
            messageBubble.classList.add('bg-ios-blue', 'text-white', 'order-1');
            
            const messageContentDiv = document.createElement('div');
            messageContentDiv.classList.add('message-content');
            messageContentDiv.innerHTML = marked.parse(content); // User messages can also be markdown if needed
            messageBubble.appendChild(messageContentDiv);

            if (isEditing) {
                const editArea = document.createElement('textarea');
                editArea.classList.add('w-full', 'p-2', 'bg-[#007aff]/80', 'text-white', 'rounded-md', 'my-2', 'text-sm', 'border', 'border-[#007aff]');
                editArea.value = content;
                messageContentDiv.innerHTML = ''; // Clear current content
                messageContentDiv.appendChild(editArea);
                
                const actionsDiv = document.createElement('div');
                actionsDiv.classList.add('mt-2', 'flex', 'space-x-2', 'justify-end');
                const doneBtn = document.createElement('button');
                doneBtn.textContent = 'Update & Resend';
                doneBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'text-white', 'px-3', 'py-1', 'rounded-md', 'text-xs');
                doneBtn.onclick = () => handleEditDone(messageId, editArea.value);
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Cancel';
                cancelBtn.classList.add('bg-gray-500', 'hover:bg-gray-600', 'text-white', 'px-3', 'py-1', 'rounded-md', 'text-xs');
                cancelBtn.onclick = () => cancelEdit(messageId, content);
                actionsDiv.appendChild(doneBtn);
                actionsDiv.appendChild(cancelBtn);
                messageBubble.appendChild(actionsDiv);
                setTimeout(() => editArea.focus(), 0);

            }


        } 
        else { // AI sender
            messageWrapper.classList.add('justify-start');
            avatar.classList.add('bg-gray-200', 'text-gray-700');
            avatar.textContent = 'AI';
            messageBubble.classList.add('bg-white', 'padding-[-10px]', 'text-gray-900');

            const tabContainer = document.createElement('div');
            tabContainer.classList.add('tabs-container');

            const tabButtons = document.createElement('div');
            tabButtons.classList.add('tab-buttons', 'flex', 'space-x-1', 'mb-2', 'border-b', 'border-gray-200');

            const tabContent = document.createElement('div');
            tabContent.classList.add('tab-content', 'text-sm', 'leading-relaxed');

            content.forEach((responseContent, index) => {
                const button = document.createElement('button');
                button.classList.add('tab-button', 'px-3', 'py-1.5', 'text-xs', 'font-medium', 'rounded-t-md', 'border-transparent', 'border', 'hover:backdrop-brightness-[0.9]', 'text-gray-700');
                button.textContent = `Response ${index + 1}`;
                button.dataset.tab = index;
                if (index === activeResponseIndex) button.classList.add('active', 'bg-ios-blue', 'text-white', 'border-ios-blue');
                
                button.onclick = (e) => {
                    // Switch tab
                    tabButtons.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active', 'bg-ios-blue', 'text-white', 'border-ios-blue'));
                    e.target.classList.add('active', 'bg-ios-blue', 'text-white', 'border-ios-blue');
                    tabContent.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
                    tabContent.querySelector(`.tab-pane[data-tab-content="${index}"]`).classList.add('active');
                    // Update activeResponseIndex in localStorage
                    if (currentSessionId && chatSessions[currentSessionId]) {
                        const msg = chatSessions[currentSessionId].messages.find(m => m.id === messageId);
                        if (msg) {
                            msg.activeResponseIndex = index;
                            saveChatSessions();
                        }
                    }
                };
                tabButtons.appendChild(button);

                const pane = document.createElement('div');
                pane.classList.add('tab-pane', 'message-content');
                pane.dataset.tabContent = index;
                // Ensure responseContent is correctly accessed if it's an object { text: "..." }
                pane.innerHTML = marked.parse(typeof responseContent === 'string' ? responseContent : responseContent.text || "Error: Invalid response format");
                if (index === activeResponseIndex) pane.classList.add('active');
                tabContent.appendChild(pane);
            });

            tabContainer.appendChild(tabButtons);
            tabContainer.appendChild(tabContent);
            messageBubble.appendChild(tabContainer);
        }

        const metaDiv = document.createElement('div');
        metaDiv.classList.add('text-xs', 'text-gray-500', 'mt-1.5', 'flex', 'justify-between', 'items-center');
        metaDiv.textContent = time;

        const actionsContainer = document.createElement('div');
        actionsContainer.classList.add('message-actions', 'flex', 'space-x-2', 'items-center', 'ml-2');

        const copyBtn = document.createElement('button');
        copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
        copyBtn.title = "Copy";
        copyBtn.onclick = () => copyMessageContent(messageId, sender);
        
        const shareBtn = document.createElement('button');
        shareBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>`;
        shareBtn.title = "Share";
        shareBtn.onclick = () => shareMessageContent(messageId, sender);

        actionsContainer.appendChild(copyBtn);
        actionsContainer.appendChild(shareBtn);

        if (sender === 'user' && !isEditing) {
            const editBtn = document.createElement('button');
            editBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>`;
            editBtn.title = "Edit";
            editBtn.classList.add('edit-btn'); // Add class to easily select
            editBtn.onclick = () => handleEditMessage(messageId);
            actionsContainer.insertBefore(editBtn, copyBtn); // Add edit before copy
        }
        
        metaDiv.appendChild(actionsContainer);
        messageBubble.appendChild(metaDiv);

        messageWrapper.appendChild(avatar);
        messageWrapper.appendChild(messageBubble);
        chatContainer.appendChild(messageWrapper);
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    function copyMessageContent(messageId, sender) {
        const session = chatSessions[currentSessionId];
        if (!session) return;
        const message = session.messages.find(m => m.id === messageId);
        if (!message) return;

        let textToCopy = "";
        if (sender === 'user') {
            textToCopy = message.text; // Copy the original text for user message
        } else { // AI
            const activeResponse = message.responses[message.activeResponseIndex || 0];
            textToCopy = activeResponse.text;
        }

        // Use a temporary textarea to copy
        const tempTextArea = document.createElement('textarea');
        tempTextArea.value = textToCopy;
        document.body.appendChild(tempTextArea);
        tempTextArea.select();
        try {
            document.execCommand('copy');
            updateStatus('Copied to clipboard!', false, false);
            setTimeout(() => updateStatus('Idle', false, false), 1500);
        } catch (err) {
            console.error('Failed to copy: ', err);
            updateStatus('Failed to copy.', true, false);
        }
        document.body.removeChild(tempTextArea);
    }

    async function shareMessageContent(messageId, sender) {
        const session = chatSessions[currentSessionId];
        if (!session) return;
        const message = session.messages.find(m => m.id === messageId);
        if (!message) return;

        let textToShare = "";
        if (sender === 'user') {
            textToShare = message.text;
        } else {
            const activeResponse = message.responses[message.activeResponseIndex || 0];
            textToShare = activeResponse.text;
        }

        if (navigator.share) {
            try {
                await navigator.share({
                    title: `Study Assistant Message (${sender})`,
                    text: textToShare,
                });
                updateStatus('Shared successfully!', false, false);
            } catch (err) {
                console.error('Error sharing: ', err);
                if (err.name !== 'AbortError') { // Don't show error if user cancelled share dialog
                    updateStatus('Error sharing message.', true, false);
                }
            }
        } else {
            copyMessageContent(messageId, sender); // Fallback to copy
            showModal('Share API not supported. Message copied to clipboard instead.');
        }
    }

    function handleEditMessage(messageId) {
        const messageElement = chatContainer.querySelector(`.message-item[data-message-id="${messageId}"]`);
        if (!messageElement) return;

        const session = chatSessions[currentSessionId];
        if (!session) return;
        const messageIndex = session.messages.findIndex(m => m.id === messageId);
        if (messageIndex === -1 || session.messages[messageIndex].sender !== 'user') return;
        
        const originalContent = session.messages[messageIndex].text;
        
        // Temporarily disable other edit buttons
        document.querySelectorAll('.message-actions .edit-btn').forEach(btn => btn.disabled = true);


        // Re-render the specific message in editing mode
        const messageBubble = messageElement.querySelector('.bg-ios-blue'); // User message bubble
        const messageContentDiv = messageBubble.querySelector('.message-content');
        const metaDiv = messageBubble.querySelector('.text-xs.text-gray-500'); // Time and actions row
        
        messageContentDiv.innerHTML = ''; // Clear existing parsed markdown

        const editArea = document.createElement('textarea');
        editArea.classList.add('w-full', 'p-2', 'bg-[#007aff]/80', 'text-white', 'rounded-md', 'my-1', 'text-sm', 'border', 'border-[#007aff]');
        editArea.value = originalContent;
        editArea.rows = Math.max(3, (originalContent.match(/\n/g) || []).length + 1); // Basic auto-height
        
        const editActionsDiv = document.createElement('div');
        editActionsDiv.classList.add('mt-2', 'flex', 'space-x-2', 'justify-end');
        
        const doneBtn = document.createElement('button');
        doneBtn.textContent = 'Update & Resend';
        doneBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'text-white', 'px-3', 'py-1', 'rounded-md', 'text-xs');
        doneBtn.onclick = () => handleEditDone(messageId, editArea.value);
        
        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.classList.add('bg-gray-500', 'hover:bg-gray-600', 'text-white', 'px-3', 'py-1', 'rounded-md', 'text-xs');
        cancelBtn.onclick = () => {
            // Restore original content
            messageContentDiv.innerHTML = marked.parse(originalContent);
            editActionsDiv.remove();
            metaDiv.classList.remove('hidden'); // Show original actions/time
            // Re-enable other edit buttons
            document.querySelectorAll('.message-actions .edit-btn').forEach(btn => btn.disabled = false);
        };
        
        editActionsDiv.appendChild(cancelBtn);
        editActionsDiv.appendChild(doneBtn);
        
        messageContentDiv.appendChild(editArea);
        messageBubble.insertBefore(editActionsDiv, metaDiv); // Insert edit actions before time/original actions
        metaDiv.classList.add('hidden'); // Hide original actions/time while editing

        setTimeout(() => editArea.focus(), 0);
    }

    async function handleEditDone(messageId, newText) {
        newText = newText.trim();
        if (!newText) {
            showModal("Edited message cannot be empty.");
            return;
        }

        const session = chatSessions[currentSessionId];
        if (!session) return;

        const messageIndex = session.messages.findIndex(m => m.id === messageId);
        if (messageIndex === -1) return;

        // Update the user's message
        session.messages[messageIndex].text = newText;
        session.messages[messageIndex].timestamp = Date.now();

        // Remove subsequent messages
        session.messages.splice(messageIndex + 1);
        
        // Re-render chat from scratch up to this point
        renderChatSession(currentSessionId); 
        // Re-enable edit buttons
        document.querySelectorAll('.message-actions .edit-btn').forEach(btn => btn.disabled = false);


        // Send the edited message to API
        const aiResponses = await sendMessageToApi(newText);
        if (aiResponses && aiResponses.length > 0) {
            const newAiMessageId = crypto.randomUUID();
            appendMessageToUI(aiResponses, 'ai', Date.now(), newAiMessageId);
            saveCurrentMessageToSession({
                id: newAiMessageId,
                sender: 'ai',
                responses: aiResponses.map(text => ({ text, id: crypto.randomUUID() })),
                timestamp: Date.now(),
                activeResponseIndex: 0
            });
        }
        saveChatSessions(); // Save all changes
    }
    
    function cancelEdit(messageId, originalContent) {
        // This function is now primarily handled inline in handleEditMessage's cancelBtn.onclick
        // Kept here in case direct call is needed, but UI restoration is key.
        const messageElement = chatContainer.querySelector(`.message-item[data-message-id="${messageId}"]`);
        if (!messageElement) return;
        const messageBubble = messageElement.querySelector('.bg-ios-blue');
        const messageContentDiv = messageBubble.querySelector('.message-content');
        const metaDiv = messageBubble.querySelector('.text-xs.text-gray-500');
        
        messageContentDiv.innerHTML = marked.parse(originalContent); // Restore original
        // Find and remove the dynamically added edit actions div
        const editActionsDiv = messageBubble.querySelector('.flex.space-x-2.justify-end');
        if (editActionsDiv) {
            editActionsDiv.remove();
        }
        metaDiv.classList.remove('hidden'); // Show original actions/time
        document.querySelectorAll('.message-actions .edit-btn').forEach(btn => btn.disabled = false);
    }


    // --- Chat History (Local Storage) ---
    function loadChatSessions() {
        const storedSessions = localStorage.getItem('chatbotSessions_v2');
        if (storedSessions) {
            chatSessions = JSON.parse(storedSessions);
        } else {
            chatSessions = {};
        }
        renderChatHistoryList();
    }

    function saveChatSessions() {
        localStorage.setItem('chatbotSessions_v2', JSON.stringify(chatSessions));
        renderChatHistoryList(); // Update list view after saving
    }

    function saveCurrentMessageToSession(messageObject) {
        if (!currentSessionId || !chatSessions[currentSessionId]) {
            console.error("No active session to save message to.");
            // Potentially create a new session if one doesn't exist, though startNewLocalSession should handle this.
            return;
        }
        chatSessions[currentSessionId].messages.push(messageObject);
        chatSessions[currentSessionId].lastUpdated = Date.now(); // For sorting history
        saveChatSessions();
    }
    
    function startNewLocalSession() {
        const newId = `session_${Date.now()}`;
        currentSessionId = newId;
        currentApiChatId = null; // Reset API chat ID for the new session
        chatSessions[newId] = {
            id: newId,
            title: "New Chat",
            messages: [],
            apiChatId: null, // Will be set after first API call
            createdAt: Date.now(),
            lastUpdated: Date.now()
        };

        // Add initial AI welcome message
        const welcomeMessageId = crypto.randomUUID();
        const welcomeMessageContent = [
            "Hello! I'm your dedicated Study Assistant. I can help you with Edexcel IAL Biology, Physics, Chemistry, and Math, as well as IGCSE Chinese and IELTS (Speaking, Writing, Listening, Reading). How can I assist you today? Feel free to ask a question about a specific topic, seek help with a practice problem, or get a concept explained!"
        ];
        chatSessions[newId].messages.push({
            id: welcomeMessageId,
            sender: 'ai',
            responses: welcomeMessageContent.map(text => ({ text, id: crypto.randomUUID() })),
            timestamp: Date.now(),
            activeResponseIndex: 0
        });

        chatContainer.innerHTML = ''; // Clear chat display
        currentChatTitle.textContent = "New Chat";
        updateStatus('Started a new chat. Type your message.', false, false);
        saveChatSessions(); // Save the new empty session
        renderChatHistoryList(); // Update list and highlight
        setActiveHistoryItem(newId);
        renderChatSession(newId); // Render the new session with welcome message
        messageInput.focus();
    }

    function loadSession(sessionId) {
        if (isWaitingForResponse) {
            showModal("Please wait for the current response to complete before switching chats.");
            return;
        }
        if (!chatSessions[sessionId]) return;
        currentSessionId = sessionId;
        currentApiChatId = chatSessions[sessionId].apiChatId || null; // Load API chat ID
        renderChatSession(sessionId);
        currentChatTitle.textContent = chatSessions[sessionId].title;
        updateStatus(`Loaded chat: ${chatSessions[sessionId].title}`, false, false);
        setActiveHistoryItem(sessionId);
        messageInput.focus();
    }

    function renderChatSession(sessionId) {
        chatContainer.innerHTML = ''; // Clear existing messages
        const session = chatSessions[sessionId];
        if (session && session.messages) {
            session.messages.forEach(msg => {
                const content = msg.sender === 'user' ? msg.text : msg.responses;
                appendMessageToUI(content, msg.sender, msg.timestamp, msg.id, msg.activeResponseIndex || 0);
            });
        }
    }

    function renderChatHistoryList() {
        chatHistoryList.innerHTML = '';
        // Sort sessions by lastUpdated, newest first
        const sortedSessionIds = Object.keys(chatSessions).sort((a, b) => {
            const sessionA = chatSessions[a];
            const sessionB = chatSessions[b];
            return (sessionB.lastUpdated || sessionB.createdAt) - (sessionA.lastUpdated || sessionA.createdAt);
        });

        if (sortedSessionIds.length === 0) {
            chatHistoryList.innerHTML = '<p class="text-xs text-gray-500 px-2">No chat history yet.</p>';
            return;
        }

        sortedSessionIds.forEach(sessionId => {
            const session = chatSessions[sessionId];
            const item = document.createElement('div');
            item.classList.add('history-item', 'p-2.5', 'rounded-md', 'hover:backdrop-brightness-[0.9]', 'cursor-pointer', 'text-sm', 'truncate', 'flex', 'justify-between', 'items-center', 'group', 'text-gray-700'); // Added text-gray-700
            item.dataset.sessionId = sessionId;
            
            const titleSpan = document.createElement('span');
            titleSpan.textContent = session.title || `Chat from ${new Date(session.createdAt).toLocaleDateString()}`;
            titleSpan.classList.add('flex-grow', 'truncate', 'pr-2');
            item.appendChild(titleSpan);

            const deleteBtn = document.createElement('button');
            deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="text-gray-500 group-hover:text-red-500 transition-opacity opacity-0 group-hover:opacity-100"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>`;
            deleteBtn.title = "Delete chat";
            deleteBtn.classList.add('p-1', 'rounded', 'hover:bg-red-500/20', 'transition-colors');
            deleteBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent loading session when deleting
                confirmDeleteSession(sessionId);
            };
            item.appendChild(deleteBtn);
            
            item.addEventListener('click', () => loadSession(sessionId));
            chatHistoryList.appendChild(item);
        });
        if (currentSessionId) {
            setActiveHistoryItem(currentSessionId);
        }
    }
    
    function confirmDeleteSession(sessionId) {
        const sessionTitle = chatSessions[sessionId]?.title || "this chat";
        showModal(
            `Are you sure you want to delete "${sessionTitle}"? This action cannot be undone.`,
            "Confirm Deletion",
            `<button id="confirmDeleteBtn" class="bg-red-600 hover:bg-red-500 text-white py-2 px-4 rounded-lg text-sm">Delete</button>`
        );
        document.getElementById('confirmDeleteBtn').onclick = () => {
            deleteSession(sessionId);
            closeModal();
        };
    }


    function deleteSession(sessionId) {
        delete chatSessions[sessionId];
        saveChatSessions(); // This also re-renders the list
        if (currentSessionId === sessionId) {
            // If current chat was deleted, start a new one
            startNewLocalSession();
        }
    }

    function setActiveHistoryItem(sessionId) {
        document.querySelectorAll('#chatHistoryList .history-item').forEach(item => {
            item.classList.remove('bg-ios-blue', 'text-white', 'font-semibold');
            item.classList.add('text-gray-700'); // Ensure default text color for inactive
            if (item.dataset.sessionId === sessionId) {
                item.classList.add('bg-ios-blue', 'text-white', 'font-semibold');
            }
        });
    }
    
    function updateChatSessionTitle(sessionId, firstMessageText) {
        if (!chatSessions[sessionId]) return;
        const maxLength = 30;
        let title = firstMessageText.substring(0, maxLength);
        if (firstMessageText.length > maxLength) title += "...";
        chatSessions[sessionId].title = title || "Untitled Chat";
        saveChatSessions(); // This will re-render the history list with the new title
        if (sessionId === currentSessionId) {
            currentChatTitle.textContent = chatSessions[sessionId].title;
        }
    }

    // --- UI Helpers ---
    function updateStatus(message, isError = false, isLoading = false) {
        statusBar.textContent = message;
        statusBar.classList.toggle('text-red-500', isError);
        statusBar.classList.toggle('text-yellow-600', isLoading && !isError); /* Darker yellow for light theme */
        statusBar.classList.toggle('text-gray-600', !isError && !isLoading); /* Default for light theme */
    }

    function disableInput(disabled) {
        messageInput.disabled = disabled;
        sendBtn.disabled = disabled;
        speechBtn.disabled = disabled;
        newChatBtn.disabled = disabled; // Also disable new chat while waiting
        messageInput.classList.toggle('bg-gray-200', disabled); /* Lighter disabled background */
        messageInput.classList.toggle('bg-white', !disabled);
        sendBtn.classList.toggle('opacity-50', disabled);
        speechBtn.classList.toggle('opacity-50', disabled);
    }

    // --- Speech Recognition ---
    function initSpeechRecognition() {
        window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!window.SpeechRecognition) {
            speechBtn.disabled = true;
            speechBtn.title = "Speech recognition not supported in your browser.";
            console.warn("Speech Recognition API not supported.");
            return;
        }

        recognition = new SpeechRecognition();
        recognition.continuous = true; // Keep listening even after a pause
        recognition.interimResults = true; // Get results as they come
        recognition.lang = 'en-US';

        recognition.onstart = () => {
            isSpeechRecognitionActive = true;
            isSpeechRecognitionManuallyStopped = false;
            toggleMicIcon(true);
            updateStatus('Listening...', false, true);
        };

        recognition.onresult = (event) => {
            let interimTranscript = '';
            let finalTranscript = '';
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    finalTranscript += event.results[i][0].transcript;
                } else {
                    interimTranscript += event.results[i][0].transcript;
                }
            }
            messageInput.value = finalTranscript + interimTranscript; // Update input field live
            adjustTextareaHeight();
        };

        recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            let errorMessage = `Speech error: ${event.error}`;
            if (event.error === 'no-speech') {
                errorMessage = 'No speech detected. Try again.';
            } else if (event.error === 'audio-capture') {
                errorMessage = 'Microphone problem. Ensure it is enabled and permitted.';
                 showModal('Microphone access might be blocked or the microphone is not working. Please check your browser settings and microphone connection.');
            } else if (event.error === 'not-allowed') {
                errorMessage = 'Mic access denied. Please allow in browser settings.';
                showModal('Microphone access was denied. Please enable it in your browser settings to use speech input.');
            }
            updateStatus(errorMessage, true, false);
            toggleMicIcon(false);
            isSpeechRecognitionActive = false;
        };

        recognition.onend = () => {
            isSpeechRecognitionActive = false;
            toggleMicIcon(false);
            if (!isSpeechRecognitionManuallyStopped) {
                // If not manually stopped (e.g. by send or toggle), and no critical error like 'not-allowed'
                // We might want to restart it here if continuous listening across pauses is desired.
                // For now, onend will stop it unless explicitly started again by toggle.
                // This makes it so user has to click mic again if it stops due to long silence.
                updateStatus('Listening ended. Click mic to start again.', false, false);
            } else {
                 updateStatus('Idle', false, false);
            }
        };
    }

    function toggleSpeechRecognition() {
        if (!recognition) return;
        if (isSpeechRecognitionActive) {
            isSpeechRecognitionManuallyStopped = true;
            recognition.stop();
        } else {
            try {
                recognition.start();
            } catch (e) {
                // This can happen if already started, though isSpeechRecognitionActive should prevent it.
                console.error("Error starting recognition:", e);
                updateStatus('Could not start listening.', true, false);
            }
        }
    }
    
    function toggleMicIcon(isActive) {
        if (isActive) {
            micIcon.classList.add('hidden');
            micActiveIcon.classList.remove('hidden');
            speechBtn.classList.add('text-red-500');
        } else {
            micIcon.classList.remove('hidden');
            micActiveIcon.classList.add('hidden');
            speechBtn.classList.remove('text-red-500');
        }
    }

</script>
</body>
</html>
